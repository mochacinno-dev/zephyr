// ═══════════════════════════════════════════════════════════
//  Zephyr Language Demo — examples.zph
// ═══════════════════════════════════════════════════════════

// ── 1. Variables & Type Inference ────────────────────────────────────────────

let name = "Zephyr"          // String, inferred
let version: Float = 1.0         // explicit type
var counter = 0              // mutable
let pi: Float = 3.14159

println("Welcome to #{name} v#{version}!")


// ── 2. String Interpolation (Ruby/Kotlin style) ──────────────────────────────

let user = "Alice"
let score = 42
println("Player #{user} scored #{score} points!")
println("Pi is approximately #{pi}")


// ── 3. Functions (Kotlin fun keyword) ────────────────────────────────────────

fun add(a: Int, b: Int) -> Int {
    a + b
}

fun greet(person: String) {
    println("Hello, #{person}!")
}

fun factorial(n: Int) -> Int {
    if n <= 1 {
        return 1
    }
    n * factorial(n - 1)
}

greet("World")
println("3 + 4 = #{add(3, 4)}")
println("10! = #{factorial(10)}")


// ── 4. Control Flow (if/elif/else as expressions) ────────────────────────────

let x = 15

if x > 10 {
    println("#{x} is greater than 10")
} elif x == 10 {
    println("#{x} is exactly 10")
} else {
    println("#{x} is less than 10")
}


// ── 5. Loops ─────────────────────────────────────────────────────────────────

// Range-based for loop
for i in 0..5 {
    print("#{i} ")
}
println("")

// While loop
var n = 10
while n > 0 {
    print("#{n} ")
    n = n - 1
}
println("")

// Iterating a list
let fruits = ["apple", "banana", "cherry"]
for fruit in fruits {
    println("#{fruit}")
}


// ── 6. Collections ───────────────────────────────────────────────────────────

var numbers = [3, 1, 4, 1, 5, 9, 2, 6]
println("List: #{numbers}")
println("Length: #{numbers.len()}")
println("Sorted: #{numbers.sort()}")
println("First: #{numbers.first()}")

// Enumerate
for pair in numbers.enumerate() {
    // pair is (index, value) tuple
}


// ── 7. Tuples ─────────────────────────────────────────────────────────────────

let point = (3, 7)
let rgb = (255, 128, 0)
println("Point: #{point}")
println("Color: #{rgb}")


// ── 8. Closures / Lambdas ────────────────────────────────────────────────────

let double = |x| => x * 2
let add_ten = |x: Int| => x + 10
let is_even = |n: Int| => n % 2 == 0

println("double(5) = #{double(5)}")
println("add_ten(7) = #{add_ten(7)}")
println("is_even(4) = #{is_even(4)}")

// Multi-line closure
let describe = |n: Int| {
    if n > 0 {
        return "positive"
    } elif n < 0 {
        return "negative"
    } else {
        return "zero"
    }
}

println("describe(42) = #{describe(42)}")
println("describe(-5) = #{describe(-5)}")


// ── 9. Structs ───────────────────────────────────────────────────────────────

struct Point {
    x: Float
    y: Float
}

struct Person {
    pub name: String
    pub age: Int
}

let p = Point { x: 3.0, y: 4.0 }
let alice = Person { name: "Alice", age: 30 }

println("Point: (#{p.x}, #{p.y})")
println("Person: #{alice.name}, age #{alice.age}")


// ── 10. Impl blocks (methods on structs) ─────────────────────────────────────

impl Point {
    pub fun distance_to(self, other: Point) -> Float {
        let dx = self.x - other.x
        let dy = self.y - other.y
        sqrt(dx * dx + dy * dy)
    }

    pub fun to_string(self) -> String {
        "(#{self.x}, #{self.y})"
    }
}

let origin = Point { x: 0.0, y: 0.0 }
let dest = Point { x: 3.0, y: 4.0 }
println("Distance: #{origin.distance_to(dest)}")


// ── 12. Pattern Matching ─────────────────────────────────────────────────────

fun describe_number(n: Int) -> String {
    match n {
        0 => "zero"
        1 | 2 | 3 => "small"
        n if n < 0 => "negative"
        _ => "large"
    }
}

println(describe_number(0))
println(describe_number(2))
println(describe_number(-5))
println(describe_number(100))


// ── 13. Null Safety — Option type ────────────────────────────────────────────

fun find_user(id: Int) -> String {
    if id == 1 {
        return "Alice"
    }
    return "nil user"
}

// Option pattern
fun safe_divide(a: Int, b: Int) -> String {
    if b == 0 {
        return "Error: division by zero"
    }
    return str(a / b)
}

println(safe_divide(10, 2))
println(safe_divide(10, 0))


// ── 14. Error Handling — Result type ─────────────────────────────────────────

fun parse_age(s: String) -> String {
    let result = s.parse_int()
    match result {
        Ok(n) if n >= 0 && n <= 150 => "Valid age: #{n}"
        Ok(n) => "Invalid age: #{n}"
        Err(e) => "Parse error: #{e}"
    }
}

println(parse_age("25"))
println(parse_age("abc"))
println(parse_age("200"))


// ── 15. Modules ───────────────────────────────────────────────────────────────

mod math_utils {
    pub fun clamp(val: Int, lo: Int, hi: Int) -> Int {
        if val < lo { return lo }
        if val > hi { return hi }
        val
    }

    pub fun lerp(a: Float, b: Float, t: Float) -> Float {
        a + (b - a) * t
    }
}


// ── 16. Generics (type parameters) ────────────────────────────────────────────

fun identity<T>(val: T) -> T {
    val
}

fun first<T>(list: [T]) -> String {
    if len(list) > 0 {
        return str(list[0])
    }
    return "empty"
}

println(identity(42))
println(identity("hello"))
println(first([10, 20, 30]))


// ── 17. String methods ────────────────────────────────────────────────────────

let s = "  Hello, Zephyr!  "
println(s.trim())
println(s.trim().to_upper())
println(s.trim().to_lower())
println(s.trim().contains("Zephyr"))
println(s.trim().replace("Zephyr", "World"))
println(s.trim().split(", "))
println("ha".repeat(3))


// ── 18. Math utilities ────────────────────────────────────────────────────────

println(abs(-42))
println(sqrt(144.0))
println(pow(2.0, 10.0))
println(min(3, 7))
println(max(3, 7))
println(floor(3.9))
println(ceil(3.1))
println(round(3.5))


// ── 19. Recursion (Fibonacci) ─────────────────────────────────────────────────

fun fib(n: Int) -> Int {
    if n <= 1 { return n }
    fib(n - 1) + fib(n - 2)
}

println("Fibonacci sequence:")
for i in 0..10 {
    print("#{fib(i)} ")
}
println("")


// ── 20. Higher-order functions ────────────────────────────────────────────────

fun apply(f: Fun, x: Int) -> Int {
    f(x)
}

fun compose(f: Fun, g: Fun) -> Fun {
    |x| => f(g(x))
}

let triple = |x| => x * 3
let inc = |x| => x + 1

println(apply(triple, 5))
println(apply(inc, 10))

let triple_then_inc = compose(inc, triple)
println("compose(inc, triple)(4) = #{triple_then_inc(4)}")


// ── 21. ref (mutable references) ─────────────────────────────────────────────

let shared = ref 0
shared.set(shared.get() + 1)
shared.set(shared.get() + 1)
println("ref value: #{shared.get()}")

// ── 22. exec() — simple shell command ─────────────────────────────────────────

println("── EXEC ────────────────────────────────")

let files = exec("ls -la")
match files {
    Ok(out) => println(out)
    Err(e)  => println("Error: #{e}")
}

// Pipes work — exec runs via /bin/sh
let line_count = exec("ls | wc -l")
match line_count {
    Ok(n)  => println("Files in dir: #{n}")
    Err(e) => println(e)
}

// Failed command puts stderr in Err
let bad = exec("cat /this/does/not/exist")
match bad {
    Ok(out) => println(out)
    Err(e)  => println("Expected error: #{e}")
}


// ── 23. exec_out() — always returns map ───────────────────────────────────────

println("── EXEC_OUT ────────────────────────────")

let res = exec_out("git --version")
let git_stdout = res["stdout"]
let git_code   = res["code"]
let git_ok     = res["ok"]
println("stdout: #{git_stdout}")
println("code:   #{git_code}")
println("ok:     #{git_ok}")

// Get stderr on failure
let fail = exec_out("ls /nonexistent")
let fail_stderr = fail["stderr"]
let fail_code   = fail["code"]
println("stderr: #{fail_stderr}")
println("code:   #{fail_code}")


// ── 24. exec_status() and exec_ok() ───────────────────────────────────────────

println("── EXEC_STATUS / EXEC_OK ───────────────")

let code = exec_status("true")
println("true exit code: #{code}")

let fail_code2 = exec_status("false")
println("false exit code: #{fail_code2}")

// exec_ok is great for checking tool availability
if exec_ok("which git") {
    println("git is installed")
} else {
    println("git not found")
}

if exec_ok("which zsh") {
    println("zsh is available")
} else {
    println("zsh not found")
}

// Check if a file exists
if exec_ok("test -f /etc/hostname") {
    let hostname = exec("/etc/hostname")
    match hostname {
        Ok(h)  => println("hostname file exists")
        Err(e) => println(e)
    }
}


// ── 25. shell() — explicit args, no injection risk ────────────────────────────

println("── SHELL ───────────────────────────────")

// Safe even with untrusted input — no shell metachar processing
let user_input = "my package; rm -rf /"   // would be dangerous in exec()
let safe = shell("echo", [user_input])
let safe_out = safe["stdout"]
println("Safe echo: #{safe_out}")          // prints literally: my package; rm -rf /

// git with explicit args
let git_log = shell("git", ["log", "--oneline", "-3"])
let git_log_ok = git_log["ok"]
if git_log_ok {
    let git_log_out = git_log["stdout"]
    println("Recent commits:\n#{git_log_out}")
} else {
    let git_log_err = git_log["stderr"]
    println("Not a git repo: #{git_log_err}")
}


// ── 26. process_run() — full control ──────────────────────────────────────────

println("── PROCESS_RUN ─────────────────────────")

// Custom environment variables
var build_env = {}
build_env["LANG"]  = "en_US.UTF-8"
build_env["TERM"]  = "xterm-256color"

let env_res = process_run("env", [], build_env, "")
let env_ok  = env_res["ok"]
if env_ok {
    // Just show a couple lines
    let env_out = env_res["stdout"]
    let first_lines = exec("echo '#{env_out}' | head -3")
    match first_lines {
        Ok(lines) => println("Env sample:\n#{lines}")
        Err(_)    => println("(env output captured)")
    }
}

// Run in a specific working directory
let tmp_ls = process_run("ls", ["-la"], [], "/tmp")
let tmp_ok  = tmp_ls["ok"]
if tmp_ok {
    println("Listed /tmp successfully")
}


// ── 27. process_spawn() — streaming output ────────────────────────────────────

println("── PROCESS_SPAWN ───────────────────────")

// process_spawn streams directly to the terminal in real time.
// Output appears as it happens, not captured into a string.
// Great for: makepkg, pacman, cargo build, long downloads, etc.

println("Running a streamed command (you will see output in real time):")
let spawn_result = process_spawn("echo line1 && echo line2 && echo line3")
match spawn_result {
    Ok(code) => println("Spawned process exited with code: #{code}")
    Err(e)   => println("Could not spawn: #{e}")
}


// ── 28. Environment variables ──────────────────────────────────────────────────

println("── ENVIRONMENT ─────────────────────────")

let home    = env_get("HOME")
let shell   = env_get("SHELL")
let editor  = env_get("EDITOR")
let missing = env_get("THIS_VAR_DOES_NOT_EXIST_XYZ")

println("HOME:    #{home}")
println("SHELL:   #{shell}")
println("EDITOR:  #{editor}")
println("Missing: #{missing}")

// Set an env var — visible to child processes spawned after this
env_set("ZEPHYR_TEST", "hello from zephyr")
let verify = env_get("ZEPHYR_TEST")
println("After set: #{verify}")

// Get all env vars
let all_env = env_all()
let path_val = all_env["PATH"]
println("PATH (first 60 chars): #{path_val}")


// ── 29. Working directory ──────────────────────────────────────────────────────

println("── WORKING DIRECTORY ───────────────────")

let original_dir = cwd()
println("Current dir: #{original_dir}")

let cd_res = set_cwd("/tmp")
match cd_res {
    Ok(_)  => {
        let new_dir = cwd()
        println("Changed to: #{new_dir}")
    }
    Err(e) => println("set_cwd failed: #{e}")
}

// Change back
let restore = set_cwd(original_dir)
match restore {
    Ok(_)  => println("Restored to: #{cwd()}")
    Err(e) => println("Could not restore: #{e}")
}

// Try to change to a nonexistent directory
let bad_cd = set_cwd("/this/path/does/not/exist")
match bad_cd {
    Ok(_)  => println("Unexpected success")
    Err(e) => println("Expected error: #{e}")
}


// ── 30. Real-world pattern: AUR helper skeleton ────────────────────────────────

println("── AUR HELPER SKELETON ─────────────────")

fun is_installed(pkg: String) -> Bool {
    exec_ok("pacman -Qi #{pkg}")
}

fun aur_clone(pkg: String, dest: String) -> Bool {
    let url = "https://aur.archlinux.org/#{pkg}.git"
    let res = shell("git", ["clone", "--depth", "1", url, dest])
    let ok  = res["ok"]
    if !ok {
        let err = res["stderr"]
        println("Clone failed: #{err}")
    }
    ok
}

fun build_package(src_dir: String) -> Bool {
    println("Building in #{src_dir}...")
    // process_spawn so the user sees makepkg output live
    let result = process_spawn("cd '#{src_dir}' && makepkg --noconfirm --needed")
    match result {
        Ok(0) => true
        Ok(n) => {
            println("makepkg exited #{n}")
            false
        }
        Err(e) => {
            println("Could not run makepkg: #{e}")
            false
        }
    }
}

fun get_git_version(repo_dir: String) -> String {
    let res = process_run("git", ["describe", "--tags", "--always"], [], repo_dir)
    let ok  = res["ok"]
    if ok {
        res["stdout"]
    } else {
        "unknown"
    }
}

// Demo the helper functions (won't actually build anything)
println("Checking if base-devel is installed...")
if is_installed("base-devel") {
    println("base-devel: installed")
} else {
    println("base-devel: not installed")
}

let ver = get_git_version(".")
println("This repo version: #{ver}")


// ── 31. Command chaining with match ──────────────────────────────────────────

println("── COMMAND CHAINING ────────────────────")

fun ensure_dir(path: String) -> Bool {
    if exec_ok("test -d #{path}") {
        true
    } else {
        let res = exec("mkdir -p #{path}")
        match res {
            Ok(_)  => true
            Err(e) => {
                println("mkdir failed: #{e}")
                false
            }
        }
    }
}

fun read_file(path: String) -> String {
    let res = exec("cat #{path}")
    match res {
        Ok(contents) => contents
        Err(_)       => ""
    }
}

fun write_file(path: String, contents: String) -> Bool {
    // Use printf to avoid issues with special chars vs echo
    let res = shell("tee", [path])
    // For simple cases, exec works fine:
    let res2 = exec("printf '%s' '#{contents}' > #{path}")
    match res2 {
        Ok(_)  => true
        Err(e) => {
            println("write failed: #{e}")
            false
        }
    }
}

// Test the helpers
let dir_ok = ensure_dir("/tmp/zephyr_test")
println("ensure_dir /tmp/zephyr_test: #{dir_ok}")

let hostname_content = read_file("/etc/hostname")
if hostname_content == "" {
    println("Could not read /etc/hostname")
} else {
    println("Hostname: #{hostname_content}")
}

// ── Final message ──────────────────────────────────────────────────────────────

println("")
println("Zephyr — !!")

// ═══════════════════════════════════════════════════════════
//  Zephyr Language Demo — examples.zph
// ═══════════════════════════════════════════════════════════

// ── 1. Variables & Type Inference ────────────────────────────────────────────

let name = "Zephyr"          // String, inferred
let version: Float = 1.0         // explicit type
var counter = 0              // mutable
let pi: Float = 3.14159

println("Welcome to #{name} v#{version}!")


// ── 2. String Interpolation (Ruby/Kotlin style) ──────────────────────────────

let user = "Alice"
let score = 42
println("Player #{user} scored #{score} points!")
println("Pi is approximately #{pi}")


// ── 3. Functions (Kotlin fun keyword) ────────────────────────────────────────

fun add(a: Int, b: Int) -> Int {
    a + b
}

fun greet(person: String) {
    println("Hello, #{person}!")
}

fun factorial(n: Int) -> Int {
    if n <= 1 {
        return 1
    }
    n * factorial(n - 1)
}

greet("World")
println("3 + 4 = #{add(3, 4)}")
println("10! = #{factorial(10)}")


// ── 4. Control Flow (if/elif/else as expressions) ────────────────────────────

let x = 15

if x > 10 {
    println("#{x} is greater than 10")
} elif x == 10 {
    println("#{x} is exactly 10")
} else {
    println("#{x} is less than 10")
}


// ── 5. Loops ─────────────────────────────────────────────────────────────────

// Range-based for loop
for i in 0..5 {
    print("#{i} ")
}
println("")

// While loop
var n = 10
while n > 0 {
    print("#{n} ")
    n = n - 1
}
println("")

// Iterating a list
let fruits = ["apple", "banana", "cherry"]
for fruit in fruits {
    println("#{fruit}")
}


// ── 6. Collections ───────────────────────────────────────────────────────────

var numbers = [3, 1, 4, 1, 5, 9, 2, 6]
println("List: #{numbers}")
println("Length: #{numbers.len()}")
println("Sorted: #{numbers.sort()}")
println("First: #{numbers.first()}")

// Enumerate
for pair in numbers.enumerate() {
    // pair is (index, value) tuple
}


// ── 7. Tuples ─────────────────────────────────────────────────────────────────

let point = (3, 7)
let rgb = (255, 128, 0)
println("Point: #{point}")
println("Color: #{rgb}")


// ── 8. Closures / Lambdas ────────────────────────────────────────────────────

let double = |x| => x * 2
let add_ten = |x: Int| => x + 10
let is_even = |n: Int| => n % 2 == 0

println("double(5) = #{double(5)}")
println("add_ten(7) = #{add_ten(7)}")
println("is_even(4) = #{is_even(4)}")

// Multi-line closure
let describe = |n: Int| {
    if n > 0 {
        return "positive"
    } elif n < 0 {
        return "negative"
    } else {
        return "zero"
    }
}

println("describe(42) = #{describe(42)}")
println("describe(-5) = #{describe(-5)}")


// ── 9. Structs ───────────────────────────────────────────────────────────────

struct Point {
    x: Float
    y: Float
}

struct Person {
    pub name: String
    pub age: Int
}

let p = Point { x: 3.0, y: 4.0 }
let alice = Person { name: "Alice", age: 30 }

println("Point: (#{p.x}, #{p.y})")
println("Person: #{alice.name}, age #{alice.age}")


// ── 10. Impl blocks (methods on structs) ─────────────────────────────────────

impl Point {
    pub fun distance_to(self, other: Point) -> Float {
        let dx = self.x - other.x
        let dy = self.y - other.y
        sqrt(dx * dx + dy * dy)
    }

    pub fun to_string(self) -> String {
        "(#{self.x}, #{self.y})"
    }
}

let origin = Point { x: 0.0, y: 0.0 }
let dest = Point { x: 3.0, y: 4.0 }
println("Distance: #{origin.distance_to(dest)}")


// ── 12. Pattern Matching ─────────────────────────────────────────────────────

fun describe_number(n: Int) -> String {
    match n {
        0 => "zero"
        1 | 2 | 3 => "small"
        n if n < 0 => "negative"
        _ => "large"
    }
}

println(describe_number(0))
println(describe_number(2))
println(describe_number(-5))
println(describe_number(100))


// ── 13. Null Safety — Option type ────────────────────────────────────────────

fun find_user(id: Int) -> String {
    if id == 1 {
        return "Alice"
    }
    return "nil user"
}

// Option pattern
fun safe_divide(a: Int, b: Int) -> String {
    if b == 0 {
        return "Error: division by zero"
    }
    return str(a / b)
}

println(safe_divide(10, 2))
println(safe_divide(10, 0))


// ── 14. Error Handling — Result type ─────────────────────────────────────────

fun parse_age(s: String) -> String {
    let result = s.parse_int()
    match result {
        Ok(n) if n >= 0 && n <= 150 => "Valid age: #{n}"
        Ok(n) => "Invalid age: #{n}"
        Err(e) => "Parse error: #{e}"
    }
}

println(parse_age("25"))
println(parse_age("abc"))
println(parse_age("200"))


// ── 15. Modules ───────────────────────────────────────────────────────────────

mod math_utils {
    pub fun clamp(val: Int, lo: Int, hi: Int) -> Int {
        if val < lo { return lo }
        if val > hi { return hi }
        val
    }

    pub fun lerp(a: Float, b: Float, t: Float) -> Float {
        a + (b - a) * t
    }
}


// ── 16. Generics (type parameters) ────────────────────────────────────────────

fun identity<T>(val: T) -> T {
    val
}

fun first<T>(list: [T]) -> String {
    if len(list) > 0 {
        return str(list[0])
    }
    return "empty"
}

println(identity(42))
println(identity("hello"))
println(first([10, 20, 30]))


// ── 17. String methods ────────────────────────────────────────────────────────

let s = "  Hello, Zephyr!  "
println(s.trim())
println(s.trim().to_upper())
println(s.trim().to_lower())
println(s.trim().contains("Zephyr"))
println(s.trim().replace("Zephyr", "World"))
println(s.trim().split(", "))
println("ha".repeat(3))


// ── 18. Math utilities ────────────────────────────────────────────────────────

println(abs(-42))
println(sqrt(144.0))
println(pow(2.0, 10.0))
println(min(3, 7))
println(max(3, 7))
println(floor(3.9))
println(ceil(3.1))
println(round(3.5))


// ── 19. Recursion (Fibonacci) ─────────────────────────────────────────────────

fun fib(n: Int) -> Int {
    if n <= 1 { return n }
    fib(n - 1) + fib(n - 2)
}

println("Fibonacci sequence:")
for i in 0..10 {
    print("#{fib(i)} ")
}
println("")


// ── 20. Higher-order functions ────────────────────────────────────────────────

fun apply(f: Fun, x: Int) -> Int {
    f(x)
}

fun compose(f: Fun, g: Fun) -> Fun {
    |x| => f(g(x))
}

let triple = |x| => x * 3
let inc = |x| => x + 1

println(apply(triple, 5))
println(apply(inc, 10))

let triple_then_inc = compose(inc, triple)
println("compose(inc, triple)(4) = #{triple_then_inc(4)}")


// ── 21. ref (mutable references) ─────────────────────────────────────────────

let shared = ref 0
shared.set(shared.get() + 1)
shared.set(shared.get() + 1)
println("ref value: #{shared.get()}")


// ── Final message ──────────────────────────────────────────────────────────────

println("")
println("Zephyr — !!")
